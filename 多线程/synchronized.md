## synchronized 同步代码块

语法 ： synchronized(共享对象的对象锁){ 线程同步代码块(线程排队)
}

每一个对象都有一把锁 任何对象都有一把锁 其实这把锁就是标记(只是叫做锁)
100个对象100个锁 1个对象1个锁

## 代码原理

# 解析
         // synchronized 放在方法修饰符上面  
         // 优点 ： 如果共享对象就是this 就可以使用这个 代码少
         // 缺点 : 对象锁一定为this 不灵活 并且该方法整个都会变为同步执行
    `    void get(int card_id, int get_value, String name, Cutmer cutmer) {
                    //原理 假设两个线程t1 t2线程并发 开始执行时 一定有先后顺序 
                    // 假设t1先执行 遇到了synchronized 这个时候自动找"后面共享对象"的对象锁
                   // 找到之后 并且占用这一把锁 然后执行同步代码块的程序 在程序执行过程中 一直占用这把锁
                  //直到 同步代码块 结束 这把锁 才会释放  
                // 假设t1正在运行中(占用这把锁) 而t2这是也遇到了synchronized 也会去占用后面共享对象的这把锁
                // 结果已经被t1占用 t2只能在外部等待(排队) t1 结束同步代码块
               // t1结束同步代码块时 会归还锁 t2就可以进来了 t2就占用这把锁 并且执行程序
              // 这样就达到了 线程排队执行
               **重点** 
              所以共享对象一定要选好 一定要是你需要排队的线程所共享的（并且要唯一且不变（不能多次new 要一个不变的值 且必须线程之间共享）,要达到占用后就没有了 必须等待）
              例如
              t1 t2 t3 t4 只有t1 t2  需要排队 那么就选一个t1 t2 共享的对象
             //这里共享的是 银行卡里的钱 或者是银行对象的任意唯一对象 因为银行是两个用户共享的 
        //注意 我这里不能使用用户对象里面的任何值 作为共享对象锁 因为用户对象不唯一 我的每一个线程都会有新的用户 所以不行 而用户的银行是不变的 
        // 老师的写法是一个用户多个线程(创建一个用户线程对象 Thread实例化多个线程) 所以它可以使用 用户的对象 作为共享对象 因为为同一个人 数据是唯一的 
           //而我的写法是 一个用户 一个线程 所以他们的共享的只有 银行(Bank)类的数据 而用户类和ATM(因为ATM会在每一个用户类里面new)的数据就完全不同 
               //还可以直接放一个"xxx" 字符串 因为字符串 都存储在字符串常量池 且地址不会改变 只不过这样写的话所有的线程都会同步执行 而不会并发
                   “xxx”的话那就是所有人取款都得排队 所以我们的原则是 卡号不一样的就不同步 卡号一致的才同步
                 
                 java的三大变量 
                 实例变量 在堆中
                 静态变量 在方法区
                 局部变量 在栈中 
                  以上三大变量中
                  局部变量 永远不会存在线程问题(因为线程安全问题 要 线程并发 共享数据 共享数据修改)
                  因为局部变量不共享(一个线程一个栈)
                  局部变量在栈中 所以局部变量永远都不会共享
                 而 另外的两个就会有安全问题 
                    
                     synchronized (map.get(card_id)){
                     
                     int value= map.get(card_id);
                     
                     if(get_value<=value){
                     
                     
                     
                     cutmer.Mouny=value;
                     map.put(card_id,value-get_value); //key相同value覆盖
                     System.out.println("取出成功 "+name+ "余额为 "+value);
                     }else {
                     System.out.println(name+"取出失败 余额不足 余额为 "+value+"目标金额为 "+get_value);
                     
                    }
    }


## 总结
- 3种写法
  - synchronized(共享对象锁){同步代码块}
  - 写在实例方法的修饰符中 synchronized void doSome(){} 共享对象锁 默认为this 同步代码块为方法体
  - 写在静态方法上的 synchronized 表示当前锁为当前类 类只有一个 再多的对象 类锁也只有一个  用于保护静态变量的线程安全