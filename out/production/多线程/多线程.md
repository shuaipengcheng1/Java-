## 一个进程有 多个线程

 一个进程是一个应用程序
 线程是一个应用程序的执行单元
 一个进程可以有多个线程
 
## 进程与线程之间的关系
 -  例子
  -  阿里巴巴 : 进程
  -  马云 : 线程
    
 - 京东 : 进程
  - 强东 : 线程
   
  - 进程a 与 进程b 的资源不会共享
   
  - 在同一进程中 线程的资源 堆内存和方法区内存共享 栈内存不共享 即一个线程一个栈内存
   
 
## 假设有十个线程 会有十个栈空间 互不干扰 这叫做多线程并发

## java的多线程 可以提升效率

## 那么用了多线程 main方法结束了 是否程序也不会结束了 因为main也是一个线程(主线程)

## 对于单核的cpu 可以多线程并发吗??

   t1 执行 t1
   t2 执行 t2
   t1不会影响t2 t2不会影响t1 这叫做真正的多线程并发 
    - 这对于多核cpu来说是可以的 比如4核就支持4个进程同时运行
    - 单核cpu 就不能做到真正的多线程并发 只能模拟
       - 比如有两个线程
         -1 音乐 2 游戏  这两个线程 单核cpu通过频繁的切换 达到误以为在同时运行
   
## java实现多线程 有两种方法
   java底层已经实现了多线程 我们只需要继承
1 编写一个类 直接继承 java.lang.Thread, 重写run方法

2 编写一个类 实现Runnable 接口 实现run方法 这种使用比较多 因为一个类实现类接口 还可以继承其他的类 


## 生命周期
- 新建状态 : 刚new出来的对象
- 就绪状态 : 调用start方法后 现在该线程可以抢夺cpu执行权(有使用时间) 
- 运行状态 : 当线程抢到了cpu执行权 运行run方法 如果执行权
使用结束(例如一秒) 则会回到就绪状态 继续抢夺cpu执行权 然后会继续上一次
  执行run方法的地方 继续执行
  - 锁池(lockpool) 如果线程在运行的时候 遇到了synchronized关键字 就会进入锁池找共享对象的对象嗦
    找到了的化就会释放当前占用的cpu执行权 没找到就在锁池中等待(阻塞 不会释放cpu使用权) 如果找到了就会进入就绪状态 继续抢夺
    cpu执行权
  - 阻塞状态 在运行状态时 如果遇到阻塞时间 例如 Scanner Sleep 就会释放当前cpu执行权 给别的线程使用
   阻塞事件结束后 便回到就绪状态 继续抢夺cpu执行权
- 死亡状态 : run方法弹栈时 线程生命周期结束  


# 线程安全
 - 为什么这是重点
   -  以后开发中 我们的项目都是运行在服务器中 而服务器已经将线程的定义 线程对象的创建
      线程的启动等 已经实现了 这些代码我们都不需要编写
   - 最重要的是 你编写的代码   或者程序 需要放在一个多线程的环境中运行
     所以 需要关注这些数据 在多线程并发的环境下面 是否安全（重点!!!!!!）
     
 - 什么时候 会不安全??
   -  *多线程并发时 有共享数据 并且共享数据有修改行为 就会存在安全问题*
      ![多线程并发问题](D:\java\多线程\多线程并发时的安全问题.png "多线程并发问题")

      
  ## 怎么解决??
      -  __所以要线程排队执行__ 不能并发 这种机制被称为线程同步机制(会牺牲效率 但是安全第一位)


## 线程同步 有两个专业术语
 - __异步编程模型__ 
    - 线程t1 和 线程t2 互不干涉 自己执行自己的 其实就是多线程并发(效率高)
 - __同步编程模型__
    - 线程t1 和 线程t2 t1必须等t2执行 换句话来说就是 t2也要等待t1执行
      这种产生了等待关系的(线程排队执行) 叫做 同步编程模型 (效率较低 安全性高)

## 以后开发中 如何解决线程安全问题

  - 一上来 就使用 线程同步吗 synchronized
     - 不是的 该方法会让系统的吞吐量变低 用户体验差 
     - 再不得已的情况下才使用
    
  - 第一种方案
    尽量使用局部变量 代替实例变量 和 静态变量
    
   - 第二种 
    - 如果一定要使用多个实例对象 那么最好一个线程一个对象 
    - 数据不共享就可以 避免安全问题
     

## 守护线程
   - Java线程分为两大类
      - 用户线程
      - 守护线程(后台线程)
        - 其中 具有代表性的是 ：垃圾回收线程(守护线程)
        - 一般守护线程是一个死循环，所有的用户线程(main就是一个用户线程)结束 守护线程自动结束
           - 用在哪里呢??  
             - 比如每天的00：00时 系统自动备份
             - 这个时候就需要使用 定时器 并且我们可以将定时器设置为守护线程
              
    
    
## 定时器 
   间隔特定的时间 执行特定的程序
      每周的要进行银行的总账操作
      每天要备份数据
   Java中 已经有类库中 提供了定时器:java.util.Timer 可以直接使用
   Java中使用的最多的定时器 是Spring框架提供的SpringTask框架
   这个框架 简单配置后 就可以完成定时器的任务
   
## Jdk 8新特性 创建线程 (创建线程方法 现在有继承Thread 实现Runnable接口 新*实现Callable接口)
这种方式 实现的线程可以获取线程run方法的返回值
之前的所有方法都不支持 因为之前的run方法 返回的是void

## 生产者 和 消费者模式 
- 1 wait() 方法作用
  - Object o =new Object()
  - o.wait(); //表示在o对象上面活跃的线程 进入等待状态(并且释放线程的对象锁),无期限等待，直到唤醒
- 2 notify()方法作用
    - o.notify(Thread) //唤醒当前o对象上指定的线程
    - o.notifyAll() // 唤醒当前对象上的所有线程
-- 这两个方法都是线程同步方法(synchronized)    
__什么是生产者和消费者模式__?
  - 一个线程负责生产
  - 一个线程负责消费
  - 最终要达到生产和消费必须均衡:
    例如:
        生产满了 就不能继续生产了,
        必须让消费线程进行消费.
        消费完了,就不能再消费了,
        必须让生产线程进行生产